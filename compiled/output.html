

<!-- ./doc/api-call/api-call.html -->


<body>
  <h1>Registry example</h1>
  <form click:passVal:fileVal:submit:log>
    <input type="text" id="user" placeholder="user">
    <input type="text" id="password" placeholder="password" change:passVal>
    <!-- <input type="text" id="passwordconf" placeholder="passwordconf" change:passVal> -->
    <!-- <input type="file" id="profile" name="profile" change:fileVal> -->
    <button type="submit" id="submit">Submit</button>
  </form>

  <script>
    customReactions.define("passVal", function(e) {
      const password = document.getElementById("password").value;
      const passwordconf = document.getElementById("passwordconf").value;

      //builtin regex for input type=text form validation
      if (password.length <= 8) { 
        this.ownerElement.addClass("invalid");
        return customReactions.break;
      }
      if (password !== passwordconf) 
        return customReactions.break;
    });

    customReactions.define("fileVal", function(e) {
      let profile = document.getElementById("profile").files[0];
      if (profile.size > 1000000) {
        this.ownerElement.addClass("tooBig")
        return customReactions.break;
      }
      if (profile.filetype !== "image/png") {
        // throw new Error("wrong file type");
        return customReactions.break;
      }
    });

    // async effect, so we should have click:button_filter::submit:log
    // 

    customReactions.define("submit", async function(e) {
      // e.preventDefault(); not needed

      // if not in the submit button, break the chain
      // this should be a filter, even in the simplest method
      // why? why have it separate, and not just in a single reaction.
      
      // 1. readability in the dom. event:filter:effect, this is what people expect.

      // 2. reusability. There are ready made filters and effects for this kind of use-case. So if you do the normal filter and normal effect, you can reuse code.

      // 3. composeability. It is easier to maintain and further develop the submit reaction with the server requirements, if kept alone and when it doesn't involve html template requirements. Similarly, it is easier to maintain the html template and the template oriented filters, if we do not have to think about server communication and requirements at the same time.

      if (e.target.id !== "submit") 
        return customReactions.break;

      const response = await fetch("/api/register", {
        method: "POST",
        body: new FormData(this.ownerElement)
      });
      const data = await response.json();
      if (data.error)  //is the .error an Error instance??
        throw new NetworkError(data.error); //todo research what type of error object to be thrown 
      return data;
    });

    customReactions.define("log", console.log);
  </script>
</body>




<!-- ./doc/autcomplete/autocomplete.html -->


<body>
  <input type="text" name="search" id="search" change::debounce:search:display>
  <input type="text" name="search" id="search" change::debounce_500:search:display>
  <div class="suggestions"></div>

  <script>
    // custom reaction implementation of debounce, delay = 1000ms
    const sleepers = new WeakMap();
    const last = new WeakMap();
    customReactions.define('debounce', async function(e, oi) {
      const key = e.currentAttribute;
      let sleeper = sleepers.get(key);
      if (!sleeper) 
        sleepers.put(key, sleeper = new Promise(r => setTimeout(r, 1000)));
      const kk = new Object();
      last.put(key, kk);
      await sleeper;
      sleepers.delete(key);
      const check = kk === last.get(key);
      last.delete(key);
      return check ? oi : customReactions.break;
    });

    // custom reaction rule implementation of debounce, debounce_delay = 1000ms
    customReactions.defineRule('debounce_', function(name) {
      const active = new WeakSet();
      const delay = name.split('_')[1];
      return function (e, oi) {
        const key = e.currentAttribute;
        if (active.has(key)) 
          return customReactions.break;
        active.add(key);
        return new Promise(r => setTimeout(r, delay)).then(() => {
          active.delete(key);
          return oi;
        });
      };
    });

    customReactions.define('search', function(e, i) {
      // is this the correct this implementation?
      let searchText = this.value;
      // if delete all text, clear the container (SHOULD THIS BE A SEPARATE CHECK W/VALIDATION??)
      if (searchText === "" || searchText === " ") {
        let container = this.parentElement.lastChild;
        container.innerHTML = "";
      };
      let searchQuery = searchText.split(' ').join('+');
      // call api to get data
      fetch('https://api.datamuse.com/sug?s=' + searchQuery)
      .then(response => response.json())
      .then(data => {
        return data;
      });
      
    });
    
    customReactions.defineRule('display', function(e, i) {
      // is this the correct this implementation?
      let container = this.parentElement.lastChild;
      // clear the container before adding new suggestions
      container.innerHTML = "";
      for (element of i) {
        let newElement = document.createElement('div');
        newElement.innerHTML = `<p>${element.word}</p>`;
        container.appendChild(newElement);
      }
    });

  </script>
</body>




<!-- ./doc/calculator/calculator.html -->


<!DOCTYPE html>
<html>
  <head>
    <title>Simple Calculator</title>
    <link rel="stylesheet" href="./calc.css" type="text/css" />
  </head>

  <body>
    <table id="calculator" click:is_number:add_number _keypress:is_number:add_number click:is_operator:do_operator _keypress:is_operator:do_operator>
      <tr>
        <td id="result"></td>
        <td id="operation"> x </td>
      </tr>
      <tr>
        <td id="input"></td>
        <td class="operator">C</td>
      </tr>
      <tr>
        <td class="number">1</td>
        <td class="number">2</td>
        <td class="number">3</td>
        <td class="operator">/</td>
      </tr>
      <tr>
        <td class="number">4</td>
        <td class="number">5</td>
        <td class="number">6</td>
        <td class="operator">*</td>
      </tr>
      <tr>
        <td class="number">7</td>
        <td class="number">8</td>
        <td class="number">9</td>
        <td class="operator">-</td>
      </tr>
      <tr>
        <td class="number">0</td>
        <td class="number">.</td>
        <td class="operator">=</td>
        <td class="operator">+</td>
      </tr>
    </table>

    <script>
      // filters
      // 1. illustrate how we retrieve data from the event and from the target in the dom.
      //    no need to add lots of attribute or elements, if we can read the state directly
      //    from either the event or the dom.
      // 2. illustrate that we pass along the filtered output to the next reaction in the chain
      //    and illustrate how we break the chain.
      customReactions.define("is_number", function (e) {
        //TODO MAKE BETTER CHECK
        //TODO MAKE BETTER CHECK
        if (["result", "operation", "input"].indexOf(e.target.id) >= 0) throw customReactions.break;
        if (e.type === "keypress" && e.key.matches(/0-9/)) return e.key;
        if (e.type === "click" && e.target.innerText.matches(/0-9/)) return e.target.innerText;
        throw customReactions.break;
      });
      customReactions.define("is_operator", function (e) {
        //TODO MAKE BETTER CHECK
        //TODO MAKE BETTER CHECK
        if (["result", "operation", "input"].indexOf(e.target.id) >= 0) throw customReactions.break;
        if (e.type === "keypress") {
          if (e.key === "Esc") return "clear";
          if (["=", "+", "-", "/", "*"].indexOf(e.key) >= 0) return e.key;
        }
        if (e.type === "click") {
          const targetTxt = e.target.innerText;
          if (["=", "+", "-", "/", "*", "clear"].indexOf(targetTxt) >= 0) return targetTxt;
        }
        throw customReactions.break;
      });

      //reducers
      //1. illustrate how we can get data from previous reactions using the `i` argument.
      //2. illustrate how we can get dom nodes we can change.
      //   Important tip: 1. add the reactions around both the trigger elements and the to-be-changed elements. This way, you can likely catch many triggers with the same custom reaction, and it is safe to find the right dom element with less chance of it being confused with another part of your dom. Add custom reactions to the shared ancestor.
      customReactions.define("do_operator", function (e, i) {
        const input = this.ownerElement.querySelector("#input");
        const result = this.ownerElement.querySelector("#result");
        const operation = this.ownerElement.querySelector("#operation");
        // we queue operations to display the previous value and the next to be computed
        // on each operation, we check if the is no input, only the queued operation is changed

        function solve() {
          const a = parseFloat(result.innerText);
          const b = parseFloat(input.innerText);
          if (operation.innerText === "+") {
            result.innerText = a + b;
          } else if (operation.innerText === "-") {
            result.innerText = a - b;
          } else if (operation.innerText === "/") {
            result.innerText = a / b;
          } else if (operation.innerText === "*") {
            result.innerText = a * b;
          }
          input.innerText = "";
          operation.innerText = "";
        }

        if (i === "clear") {
          result.innerText = "";
          input.innerText = "";
          operation.innerText = "";
          return;
        }

        // if neither value nor input available, do nothing.
        if (input.innerText === "" && result.innerText === "") return;

        // if there is no result, we set the result to the input and clear the input, also set the operation later.
        if (result.innerText === "" && input.innerText !== "") {
          result.innerText = input.innerText;
          input.innerText = "";
        }

        // if there is a result, an input, and a queued operation, we compute the result and set the next operation later.'
        if (result.innerText !== "" && input.innerText !== "" && operation.innerText !== "") {
          solve();
        }
        
        // CHECK IF SOLVING IS NEEDED
        if (i === "=") {
          solve();
          return;
        }

        //if there is a result but not an input only change the operation to be computed next.

        //By this point, we can be sure that the result is set, and the input is clear, and the operation can be changed.
        if (i === "+") {
          operation.innerText = "+";
        } else if (i === "-") {
          operation.innerText = "-";
        } else if (i === "/") {
          operation.innerText = "/";
        } else if (i === "*") {
          operation.innerText = "*";
        }
      });

      customReactions.define("add_number", function (e, i) {
        const input = this.ownerElement.querySelector("#input");
        if (i === "." && input.innerText.indexOf(".") >= 0) return;
        input.innerText += i;
      });
    </script>
  </body>
</html>





<!-- ./doc/carousele/carousele.html -->


<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      .carousele, .carouseleCont {
        display: flex;
        gap: 20px;
      }

      .carouseleCont {
        overflow: hidden;
        width: 400px;
        height: 300px;
        position: relative;
      }
      .cItem {
        width: 210px;
        height: 210px;
        overflow: hidden;
        position: absolute;
        flex-shrink: 0;
        top: 50px;
        transition: all 0.5s;
      }
      .cItem1 {
        left: 40%;
        transform: translateX(-50%);
        z-index: -1;
      }
      .cItem2 {
        left: 50%;
        transform: translateX(-50%);
      }
      .cItem3 {
        left: 60%;
        transform: translateX(-50%);
        z-index: -1;
      }
    </style>

    <script>
      function moveLeft() {
        let items = document.getElementsByClassName("cItem");
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          let className = item.className;
          let number = className.charAt(className.length - 1);
          number = parseInt(number);
          if (number === 3) {
            number = 1;
          } else {
            number = number + 1;
          }
          item.className = "cItem " + "cItem" + number;
        }
      }

      function moveRight() {
        let items = document.getElementsByClassName("cItem");
        for (let i = 0; i < items.length; i++) {
          let item = items[i];
          let className = item.className;
          let number = className.charAt(className.length - 1);
          number = parseInt(number);
          if (number === 1) {
            number = 3;
          } else {
            number = number - 1;
          }
          item.className = "cItem " + "cItem" + number;
        }
      }

      customReactions.define('rightBtn', moveRight);
      customReactions.define('leftBtn', moveLeft);

    </script>
  </head>
  <body>
    <h2>Carousele Example</h2>

    <div class="carousele">
      <button id="Left" click:leftBtn><</button>
      <div class="carouseleCont">
        <div class="cItem cItem1" >
          <img src="https://via.placeholder.com/200" alt="" style="border: green solid 1px;"/>
        </div>
        <div class="cItem cItem2">
          <img src="https://via.placeholder.com/200" alt="" style="border: blue solid 1px;"/>
        </div>
        <div class="cItem cItem3">
          <img src="https://via.placeholder.com/200" alt="" style="border: red solid 1px;"/>
        </div>
      </div>
      <button id="Right" click:rightBtn>></button>
    </div>
  </body>
</html>





<!-- ./doc/infinite-scroll/scroll.html -->


<body>
  <h1>Infinite Scroll Example</h1>

  <div id="grid"></div>
  <div inView:loadmore>Loading</div>
  
  <script>
    //load more reaction appends 10 items to the grid
    customReaction.define('loadMore', () => {
      const grid = this.ownerElement.previousElementSibling

      for (let i = 0; i < 10; i++) {
        const div = document.createElement('div')
        div.innerText = `Item ${i}`
        div.setAttribute('inView:render', 'click:modalOpen')
        div.style.opacity = '0'
        grid.appendChild(div)
      }
    })

    //make each element visible when it is in view
    customReaction.define('render', () => {
      this.ownerElement.style.opacity = '1'
    })

    customReaction.define('modalOpen', () => {
      const number = this.ownerElement.innerText.split(' ')[1]
      alert(`Modal Opened for ${number}`)
    })
  </script>
</body>




<!-- ./doc/theme-toggle/theme.html -->


<body>
  <h1>Theme Toggle Example</h1>

  <button click:themeTogle>Toggle Theme</button>
  <script>
    customReaction.define('themeTogle', () => {
      document.body.classList.toggle('dark')
    })
  </script>
</body>




<!-- ./test/elementObserver/test1.html -->


<test-html test="test_click_colon.html">
  <script expected>[
    ["click:bob", "DIV"],
    ["offline:something", "H3"],
    ["online:hello", "DIV"],
    ["mousemove:santa", "H1"],
    [":bob:bob", "P"],
    ["web-comp:one", "WEB-COMP"],
    ["web-comp:two", "WEB-COMP"]
  ]
  </script>
</test-html>

<script src="https://cdn.jsdelivr.net/gh/orstavik/TestHTML@v1.0.3/TestHTML.js"></script>




<!-- ./test/elementObserver/test_click_colon.html -->


<script src="../../src/nativeEvents.js"></script>
<script src="../../src/elementObserver2.js"></script>
<script src="../../src/test-framework.js"></script>

<div click:bob></div>

<script id=one>
  document.body.insertAdjacentHTML("afterbegin", "<h3 offline:something>else</h3>");
</script>

<div online:hello>number 2</div>

<script id=two>
  setTimeout(function () {
    document.body.lastElementChild.innerHTML = "<h1 mousemove:santa>hello</h1>";
  }, 1000);
</script>

<web-comp web-comp:one>one</web-comp>

<script id=three>
  class WebComp extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
      this.shadowRoot.innerHTML = "<p :bob:bob>hello sunshine</p>";
    }
  }
  customElements.define("web-comp", WebComp);

  document.body.insertAdjacentHTML("beforeend", "<web-comp web-comp:two>two</web-comp>");
</script>
<div> last child </div>




<!-- ./test/scriptBlocker/block_script_test.html -->



<script>
function hello(){
  let latest = document.documentElement;
  while (latest.lastElementChild)
    latest = latest.lastElementChild;

  console.log("sunshine", latest.tagName);
}
hello();
</script>

<script src="blockscript.js"></script>

<h1>hello sunshine</h1>

<script>console.log("sync1");debugger</script>
<script src='data:text/javascript;base64,Y29uc29sZS5sb2coJ3N5bmMyJyk='>sync2</script>
<script defer>console.log("defer1");</script>
<script src='data:text/javascript;base64,Y29uc29sZS5sb2coJ2RlZmVyMicp'>defer2</script>
<script async>console.log("async1");</script>
<script src='data:text/javascript;base64,Y29uc29sZS5sb2coJ2FzeW5jMicp'>async2</script>

<img onload="hello()" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="Tiny transparent GIF" />
<div>curious when this is visible</div>





<!-- ./test/scriptBlocker/nativeEvents.html -->


<script src="nativeEvents.js"></script>
<script>

  for (t of ["domEvents", "documentEvents", "windowEvents"]) {
    events = [...window[t]()];
    console.log(t, events.length);
    console.log(...events);
  }

  console.log([
    ["NativeDCLEvent", "domcontentloaded"],
    ["ShadowRootEvent", "touchstart"],
    ["ShadowRootEvent", "touchmove"],
    ["ShadowRootEvent", "touchend"],
    ["ShadowRootEvent", "touchcancel"]
  ]);

  // const protos = {
  //   window,
  //   DocumentProto: Document.prototype,
  //   ElementProto: Element.prototype,
  //   HtmlElementProto: HTMLElement.prototype
  // };
  // //1. get all the on<event> for the different types of targets.
  // for (let p in protos)
  //   protos[p] = Object.keys(protos[p]).filter(k => k.startsWith("on")).map(str => str.substring(2));

  // //2. merge HtmlElementProto and ElementProto (irrelevant distinction for us here)
  // protos.ElementProto.push(...protos.HtmlElementProto);
  // delete protos.HtmlElementProto;

  // //3. invert the map, event=>[targetType, ...]
  // const eventToType = {};
  // for (let p in protos)
  //   for (let eventName of protos[p])
  //     (eventToType[eventName] ??= []).push(p);

  // //4. rename targetType
  // for (let [key, value] of Object.entries(eventToType)) {
  //   if (value.length === 1)
  //     eventToType[key] = value[0];
  //   else if (value.length === 3)
  //     eventToType[key] = "DOM";
  //   else if (value.length === 2 && value.indexOf("window") < 0)
  //     eventToType[key] = "DOM*";
  //   else
  //     eventToType[key] = "ERROR, haven't seen this before";
  // }

  // //5. invert the map back again.
  // const typeToEvent = {};
  // for (let event in eventToType)
  //   (typeToEvent[eventToType[event]] ??= []).push(event);

  // //6. print the results against definitions
  // const allEvents = new Set(Object.values(typeToEvent).flat(Infinity));
  // console.log(`native events (count: ${allEvents.size}).`);

  // //7. add problem events
  // typeToEvent["problems"] = [
  //   "domcontentloaded",//weirdo. No window.onDOMContentLoaded & case sensitive. annoying.
  //   "touchstart", "touchmove", "touchend", "touchcancel",  //no element.ontouchstart = handler. Annoying.
  // ];

  // for (let type in typeToEvent) {
  //   console.log(type, typeToEvent[type].length);
  //   for (let event of typeToEvent[type])
  //     console.log(customAttributes.getDefinition("_" + event, ["_" + event]).name, event);
  // }

  // //conclusion (oct 2022, Chrome):
  // //native events (128 / 125 inside iframe)
  // //1. 21 windowOnly events (18 inside iframe: devicemotion, deviceorientation, deviceorientationabsolute are not listed in iframe.)
  // //2. 6 documentOnly events
  // //3. 101 DOM events. Of these DOM events, there are 10 events that do not have a `window.on___` property.
  // //   But it works listening for at least some of these events using window.addEventListener.
  // //   We call these DOM* events, but they are not really different from the other DOM events.
</script>




<!-- ./test/scriptBlocker/test1.html -->


<test-html test="block_script_test.html">
  <script expected>[
    ["sunshine", "SCRIPT"],
    ["sunshine", "DIV"]
  ]</script>
</test-html>

<test-html test="nativeEvents.html">
  <script expected>[
    "native events (count: 129).",
    ["DOM", 94],
    ["ShadowRootEvent", "search"],
    ["ShadowRootEvent", "beforexrselect"],
    ["ShadowRootEvent", "abort"],
    ["ShadowRootEvent", "beforeinput"],
    ["ShadowRootEvent", "blur"],
    ["ShadowRootEvent", "cancel"],
    ["ShadowRootEvent", "canplay"],
    ["ShadowRootEvent", "canplaythrough"],
    ["ShadowRootEvent", "change"],
    ["ShadowRootEvent", "click"],
    ["ShadowRootEvent", "close"],
    ["ShadowRootEvent", "contextlost"],
    ["ShadowRootEvent", "contextmenu"],
    ["ShadowRootEvent", "contextrestored"],
    ["ShadowRootEvent", "cuechange"],
    ["ShadowRootEvent", "dblclick"],
    ["ShadowRootEvent", "drag"],
    ["ShadowRootEvent", "dragend"],
    ["ShadowRootEvent", "dragenter"],
    ["ShadowRootEvent", "dragleave"],
    ["ShadowRootEvent", "dragover"],
    ["ShadowRootEvent", "dragstart"],
    ["ShadowRootEvent", "drop"],
    ["ShadowRootEvent", "durationchange"],
    ["ShadowRootEvent", "emptied"],
    ["ShadowRootEvent", "ended"],
    ["ShadowRootEvent", "error"],
    ["ShadowRootEvent", "focus"],
    ["ShadowRootEvent", "formdata"],
    ["ShadowRootEvent", "input"],
    ["ShadowRootEvent", "invalid"],
    ["ShadowRootEvent", "keydown"],
    ["ShadowRootEvent", "keypress"],
    ["ShadowRootEvent", "keyup"],
    ["ShadowRootEvent", "load"],
    ["ShadowRootEvent", "loadeddata"],
    ["ShadowRootEvent", "loadedmetadata"],
    ["ShadowRootEvent", "loadstart"],
    ["ShadowRootEvent", "mousedown"],
    ["ShadowRootEvent", "mouseenter"],
    ["ShadowRootEvent", "mouseleave"],
    ["ShadowRootEvent", "mousemove"],
    ["ShadowRootEvent", "mouseout"],
    ["ShadowRootEvent", "mouseover"],
    ["ShadowRootEvent", "mouseup"],
    ["ShadowRootEvent", "mousewheel"],
    ["ShadowRootEvent", "pause"],
    ["ShadowRootEvent", "play"],
    ["ShadowRootEvent", "playing"],
    ["ShadowRootEvent", "progress"],
    ["ShadowRootEvent", "ratechange"],
    ["ShadowRootEvent", "reset"],
    ["ShadowRootEvent", "resize"],
    ["ShadowRootEvent", "scroll"],
    ["ShadowRootEvent", "securitypolicyviolation"],
    ["ShadowRootEvent", "seeked"],
    ["ShadowRootEvent", "seeking"],
    ["ShadowRootEvent", "select"],
    ["ShadowRootEvent", "slotchange"],
    ["ShadowRootEvent", "stalled"],
    ["ShadowRootEvent", "submit"],
    ["ShadowRootEvent", "suspend"],
    ["ShadowRootEvent", "timeupdate"],
    ["ShadowRootEvent", "toggle"],
    ["ShadowRootEvent", "volumechange"],
    ["ShadowRootEvent", "waiting"],
    ["ShadowRootEvent", "webkitanimationend"],
    ["ShadowRootEvent", "webkitanimationiteration"],
    ["ShadowRootEvent", "webkitanimationstart"],
    ["ShadowRootEvent", "webkittransitionend"],
    ["ShadowRootEvent", "wheel"],
    ["ShadowRootEvent", "auxclick"],
    ["ShadowRootEvent", "gotpointercapture"],
    ["ShadowRootEvent", "lostpointercapture"],
    ["ShadowRootEvent", "pointerdown"],
    ["ShadowRootEvent", "pointermove"],
    ["ShadowRootEvent", "pointerrawupdate"],
    ["ShadowRootEvent", "pointerup"],
    ["ShadowRootEvent", "pointercancel"],
    ["ShadowRootEvent", "pointerover"],
    ["ShadowRootEvent", "pointerout"],
    ["ShadowRootEvent", "pointerenter"],
    ["ShadowRootEvent", "pointerleave"],
    ["ShadowRootEvent", "selectstart"],
    ["ShadowRootEvent", "selectionchange"],
    ["ShadowRootEvent", "animationend"],
    ["ShadowRootEvent", "animationiteration"],
    ["ShadowRootEvent", "animationstart"],
    ["ShadowRootEvent", "transitionrun"],
    ["ShadowRootEvent", "transitionstart"],
    ["ShadowRootEvent", "transitionend"],
    ["ShadowRootEvent", "transitioncancel"],
    ["ShadowRootEvent", "beforematch"],
    ["ShadowRootEvent", "contentvisibilityautostatechange"],
    ["window", 18],
    ["NativeWindowEvent", "appinstalled"],
    ["NativeWindowEvent", "beforeinstallprompt"],
    ["NativeWindowEvent", "afterprint"],
    ["NativeWindowEvent", "beforeprint"],
    ["NativeWindowEvent", "beforeunload"],
    ["NativeWindowEvent", "hashchange"],
    ["NativeWindowEvent", "languagechange"],
    ["NativeWindowEvent", "message"],
    ["NativeWindowEvent", "messageerror"],
    ["NativeWindowEvent", "offline"],
    ["NativeWindowEvent", "online"],
    ["NativeWindowEvent", "pagehide"],
    ["NativeWindowEvent", "pageshow"],
    ["NativeWindowEvent", "popstate"],
    ["NativeWindowEvent", "rejectionhandled"],
    ["NativeWindowEvent", "storage"],
    ["NativeWindowEvent", "unhandledrejection"],
    ["NativeWindowEvent", "unload"],
    ["DocumentProto", 7],
    ["NativeDocumentEvent", "readystatechange"],
    ["NativeDocumentEvent", "pointerlockchange"],
    ["NativeDocumentEvent", "pointerlockerror"],
    ["NativeDocumentEvent", "freeze"],
    ["NativeDocumentEvent", "resume"],
    ["NativeDocumentEvent", "visibilitychange"],
    ["NativeDocumentEvent", "prerenderingchange"],
    ["DOM*", 10],
    ["ShadowRootEvent", "beforecopy"],
    ["ShadowRootEvent", "beforecut"],
    ["ShadowRootEvent", "beforepaste"],
    ["ShadowRootEvent", "fullscreenchange"],
    ["ShadowRootEvent", "fullscreenerror"],
    ["ShadowRootEvent", "webkitfullscreenchange"],
    ["ShadowRootEvent", "webkitfullscreenerror"],
    ["ShadowRootEvent", "copy"],
    ["ShadowRootEvent", "cut"],
    ["ShadowRootEvent", "paste"],
    ["problems", 5],
    ["NativeDCLEvent", "domcontentloaded"],
    ["ShadowRootEvent", "touchstart"],
    ["ShadowRootEvent", "touchmove"],
    ["ShadowRootEvent", "touchend"],
    ["ShadowRootEvent", "touchcancel"]
  ]</script>
</test-html>

<script src="https://cdn.jsdelivr.net/gh/orstavik/TestHTML@v1.0.3/TestHTML.js"></script>




<!-- ./test/test.html -->





